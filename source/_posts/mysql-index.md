---
title: MYSQL索引（1）
date: 2022.11.26
updated: 2022.11.26 
type: 
cover:
comments:
cover:
description: 关于MYSQL索引的介绍
keywords:
top_img: 
mathjax:
katex:
aside:
aplayer:
highlight_shrink:
categories: 
  - study
tags:
  - mysql
---

# 1.什么是MySQL索引？

## 1.1、索引的分类

**主键索引：`primary key`**

- 设定为主键后，数据库自动建立索引，InnoDB为聚簇索引，主键索引列值不能为空（Null）。

**唯一索引：**

- 索引列的值必须唯一，但允许有空值（Null），但只允许有一个空值（Null）。

**复合索引：**

- 一个索引可以包含多个列，多个列共同构成一个复合索引。

**全文索引：**

- Full Text（MySQL5.7之前，只有MYISAM存储引擎引擎支持全文索引）。
- 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找允许在这些索引列中插入重复值和空值。全文索引可以在**Char、VarChar** 上创建。

**空间索引：**

- MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型，MySQL在空间索引这方年遵循OpenGIS几何数据模型规则。

**前缀索引：**

- 在文本类型为char、varchar、text类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

## 1.2、创建索引的基本操作

**创建主键索引：**

```mysql
#建表时，主键默认为索引
CREATE TABLE IF NOT EXISTS `posts`(
   `uid` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
   `title` VARCHAR(100) NOT NULL,
   `author` VARCHAR(40) NOT NULL,
   `submission_date` DATE
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

#查看user表中的索引
show index from posts;
```



**创建单列索引：**

```mysql
#创建单列索引，只能包含一个字段
create index title_index on posts(title);
```



**创建唯一索引：**

```mysql
#创建唯一索引，只能有一个列
create unique index author_index on posts(author);
```



**创建复合索引：**

```mysql
#复合索引
create index title_author_index on posts(title,author);
```



![image-20221126220757597](https://picture.noel.ga/202211262207726.png)



```mysql
CREATE INDEX indexName ON tableName (columnName(length) [ASC|DESC]);

ALTER TABLE tableName ADD INDEX indexName(columnName(length) [ASC|DESC]);

CREATE TABLE tableName(  
  columnName1 INT(8) NOT NULL,   
  columnName2 ....,
  .....,
  INDEX [indexName] (columnName(length))  
);
```

这种创建方式可以给一张已存在的表结构添加索引，其中需要指定几个值：

- `indexName`：当前创建的索引，创建成功后叫啥名字。
- `tableName`：要在哪张表上创建一个索引，这里指定表名。
- `columnName`：要为表中的哪个字段创建索引，这里指定字段名。
- `length`：如果字段存储的值过长，选用值的前多少个字符创建索引。
- `ASC|DESC`：指定索引的排序方式，`ASC`是升序，`DESC`是降序，默认`ASC`。

### **满足复合索引的查询的两大原则：**

**假如创建的复合索引为三个字段，按顺序分别是(name,age,sex)
在查询时能利用复合索引的查询条件如下：**

- 1、最左前缀原则(如下四种都满足条件)

  ```mysql
  select * from user where name = ? 
  select * from user where name = ? and age = ?
  select * from user where name = ? and sex = ?
  select * from user where name = ? and age = ? and sex = ?
  ```

- 1.1、如下是不满足最前左缀的条件（但是不是全部都不生效，如下第2原则解释）

  ```mysql
  select * from user where name = ? and sex = ? and age = ?
  select * from user where age = ? and sex = ? and name = ?
  select * from user where sex = ? and age = ? and name = ?
  select * from user where age = ? and sex = ?
  …………
  ```

- 2.MySQL 引擎在执行查询时，为了更好地利用索引，在查询过程中会动态调整查询字段的顺序！**(也就是说，当条件中的字段全部达到复合索引中的字段时，可以动态调整字段顺序，使其满足最前左缀)**

  ```mysql
  #可以使用复合索引：索引中包含的字段数都有，只是顺序不正确，在执行的时候可以动态调整为最前左缀
  select * from user where sex = ? and age = ? and name = ?
  select * from user where age = ? and sex = ? and name = ?
  
  #不可以使用复合索引：因为缺少字段，并且顺序不正确
  select * from user where sex = ? and age = ? 
  select * from user where age = ? and name = ?
  select * from user where age = ?
  select * from user where sex = ? 
  ```

# 2.索引的数据结构

MySQL索引使用的数据结构主要有`BTree索引`和`hash索引`。

对于hash索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景建议选择BTree索引。

## 2.1、根据存储引擎的不同，实现方式也不同

MySQL的索引数据结构`最常使用的是B树中的B+Tree`.

- **MyISAM**：
- **InnoDB**：

## 2.2、Hash表

Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的形式存储数据。我们使用hash表存储表数据结构，**Key可以存储索引列，Value可以存储行记录或者行磁盘地址**。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时只能通过扫描全表的方式，筛选出符合条件的数据。

**显然这种方式，不适合我们经常需要查找和范围查找的数据库索引使用。**

## 2.3、B树：改造二叉树

MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO操作非常耗时，`所以我们优化的重点就是尽量减少磁盘的IO操作`。访问二叉树的每个节点都会发生一次IO，`如果想要减少磁盘IO操作，就需要尽量降低树的高度`。

**那如何降低树的高度呢？**

假如key为bigint=8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间为（8+4*2=16）。

因为在MySQL的InnoDB引擎的一次IO操作会读取一页的数据量（默认一页大小为16K），而二叉树一次IO操作的有效数据量只有16字节，空间利用率极低。为了最大化的利用一次IO操作空间，一个解决方法就是在一个节点处存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，`通过增加树的分叉树，将树的体型从高瘦变成了矮胖`。构建1百万条数据，树的高度需要2层就可以（1000*1000=1百万），也就是说只需要两次磁盘IO操作就可以查询到数据，磁盘IO操作次数变少了，查询数据的效率整体也就提高了。

这种数据结构我们称之为B树，==B树是一种多叉平衡查找树==，如下图主要特点：

1. B树的节点中存储这多个元素，每个内节点有多个分叉。
2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点中都存储数据。
3. 父节点当中的元素不会出现在子节点中。
4. 所有的叶子节点都位于同一层，叶子节点具有相同的深度，叶子节点之间没有指针连接。

![2](https://picture.noel.ga/202211262236745.png)

举个简单的例子，在B树中查询数据的情况：

> 假如我们要查询key等于10对应的数据data，根据上图我们可知在磁盘中的查询路径是：**磁盘块1->磁盘块2->磁盘块6**

- 第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10<15，走左子树，到磁盘中寻址到磁盘块2。
- 第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，10>7，走右子树，到磁盘中寻址到磁盘块6。
- 第三次磁盘IO：讲磁盘块6加载到内存中，在内存中从头遍历比较，10=10，找到key=10的位置，取出对应的数据data，如果data存储的是行记录，直接取出数据，查询结束；如果data存储的是行磁盘地址，还需要根据磁盘地址到对应的磁盘中取出数据，查询结束。

**看到上面的情况，觉得B树已经很理想了，但是其中还是存在可以优化的地方：**

- B树不支持范围查询的快速查找，例如：仍然根据上图，我们想要查询10到35之间的数据，查找到10之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
- 如果data存储的是行记录，行的大小随着列数的增加，所占空间会变大，这时一页中可存储的数据量就会减少，树相应就会变高，磁盘IO次数就会随之增加，有待优化。

## 2.6、B+树：改造B树

B+树，作为B树的升级版，MySQL在B树的基础上继续进行改造，使用B+树构建索引。B+树和B树最主要的区别在于==非叶子节点是否存储数据==的问题。

- B树：叶子节点和非叶子节点都会存储数据。
- B+树：只有叶子节点才会存储数据，非叶子节点只存储键值key；叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

### **B+树的大致数据结构：**

![3](https://picture.noel.ga/202211262241972.png)

B+树的最底层叶子节点包含了所有的索引项。从上图可以看出，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。所以在查询数据的情况下每次的磁盘IO次数跟树的高度有直接的关系；但是从另一方面来说，由于数据都被存放到了叶子节点，所以存放索引的磁盘块，所存放的的索引数量会随之增加，所以相对于B树来说，B+树的树高理论情况下是比B树树高要矮的。
**但是也存在索引覆盖查询的情况，在索引中数据满足了查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。**

### **等值查询实例：**

假如我们要查询key为9对应的数据data，查询路径为：**磁盘块1->磁盘块2->磁盘块6**。

- 第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，9<15，走左子树，到磁盘寻址定位到磁盘块2。
- 第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7<9<12，到磁盘中寻址定位到磁盘块6。
- 第三次磁盘IO：将磁盘块6加载到内存中，在内存中从头遍历比较，在第三个索引中找到9，取出对应的数据data，如果data存储的是行记录，直接取出data，查询结束；如果存储的是磁盘地址，还需要根据磁盘地址再次寻址定位到指定磁盘取出数据，查询终止。

![4](https://picture.noel.ga/202211262246198.png)

### **范围查询实例：**

假如我们想要查找9和26之间的数据，查找路径为：**磁盘块1->磁盘块2->磁盘块6->磁盘块7**

- 前三次磁盘IO：首先查找到键值为9对应的数据（定位到磁盘块6），然后缓存大结果集中。这一步和前面等值查询流程一样，发生了三次磁盘IO。
- 继续查询，查找到节点15之后，底层的所有叶子节点是一个有序列表，我们从磁盘块6中的键值9开始向后遍历筛选出所有符合条件的数据。
- 第四次磁盘IO：根据磁盘块6的后继指针到磁盘中寻址定位到磁盘块7，将磁盘块7加载到内存中，在内存中从头遍历比较，9<25<26，9<26<=26，将数据data缓存到结果集中。
- 逐渐具备唯一性（后面不会再有<=26的数据），不需要再向后查找，查询结束，将结果集返回给用户。

![6](https://picture.noel.ga/202211262247137.png)




转载至 [MySQL索引详解（一文搞懂）](https://developer.aliyun.com/article/831250)